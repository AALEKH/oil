#!/usr/bin/env bash
#
# Actions invoked by build.ninja, which is generated by build/native_graph.py.
#
# Also some non-Ninja wrappers.
#
# Usage:
#   build/native-steps.sh <function name>

set -o nounset
set -o pipefail
set -o errexit

source build/common.sh  # for $CXXFLAGS

# for 'perf'.  Technically this may slow things down, but it was in the noise
# on parsing configure-coreutils.
CPPFLAGS="$CXXFLAGS -fno-omit-frame-pointer"

# this flag is only valid in Clang, doesn't work in continuous build
if test "$CXX" = "$CLANGXX"; then
  CPPFLAGS="$CPPFLAGS -ferror-limit=1000"
fi

# chrome://tracing
# https://aras-p.info/blog/2019/01/16/time-trace-timeline-flame-chart-profiler-for-Clang/
ftime-trace-demo() {
  local dir=_tmp/ftime-trace
  mkdir -p $dir
  rm -f -v $dir/*

  echo ' int foo() { return 32; } ' > $dir/lib.cc
  echo ' int main() { return 42; } ' > $dir/main.cc

  #$CLANGXX --version

  # Compiler annoyances:
  # - -ftime-trace is IGNORED without -c, which means compile without linking
  # - Can't specify -o with multiple source files

  set -x
  $CLANGXX -ftime-trace -o $dir/main.o -c $dir/main.cc 
  $CLANGXX -ftime-trace -o $dir/lib.o -c $dir/lib.cc
  set +x
  echo

  ls -l $dir
  echo

  # .o file is 'relocatable', otherwise it's 'executable'
  file $dir/*
  echo
}

preprocessor-demo() {
  local dir=_tmp/preprocess
  mkdir -p $dir
  rm -f -v $dir/*

  echo '
#include <stdio.h>
int foo() { return 32; }
' > $dir/lib.cc

  # Create a file that gets included twice
  { 
    echo '#ifndef LIB2_H'
    echo '#define LIB2_H'

    echo '#include <vector>' 

    # This doesn't make a difference!  The preprocessor strips comments
    for i in $(seq 1000); do
      echo '// comment'
    done

    for i in $(seq 1000); do
      echo "int foo$i() { return $i; }"
    done

    echo '#endif  // LIB2_H'
  } > $dir/lib2.h

  echo '
#include <vector>
#include "lib2.h"  // transitive include

inline int bar() { return 1; }
' > $dir/lib.h

  # wow 12K files for <vector>
  echo '
#include <vector>
#include "lib.h"
#include "lib2.h"  // duplicate include

int main() { return 42; }
' > $dir/main.cc

  $CXX -E $dir/lib.cc > $dir/lib.post.cc

  $CXX -E $dir/main.cc > $dir/main.post.cc

  wc -l $dir/*.post.cc

  # make sure the file compiles
  $CXX -o $dir/main $dir/main.cc
}


compile() {
  ### Invoked by build.ninja, and by test/cpp-unit.sh

  local out=$1
  shift

  local flags="$CPPFLAGS"
  local link_flags=''
  case $out in
    *.opt)
      flags="$CPPFLAGS -O2 -g -D DUMB_ALLOC"
      # To debug crash with 8 byte alignment
      #flags="$CPPFLAGS -O0 -g -D DUMB_ALLOC -D ALLOC_LOG"
      ;;
    *.uftrace)
      # -O0 creates a A LOT more data.  But sometimes we want to see the
      # structure of the code.
      # vector::size(), std::forward, len(), etc. are not inlined.
      # Also List::List, Tuple2::at0, etc.
      #local opt='-O2'
      local opt='-O0'

      # Do we want DUMB_ALLOC here?
      flags="$CPPFLAGS $opt -g -pg"
      ;;
    *.malloc)
      flags="$CPPFLAGS -O2 -g"
      ;;
    *.tcmalloc)
      flags="$CPPFLAGS -O2 -g -D TCMALLOC"
      link_flags='-ltcmalloc'
      ;;
    *.asan)
      # Note: Clang's ASAN doesn't like DUMB_ALLOC, but GCC is fine with it
      flags="$CPPFLAGS -O0 -g -fsanitize=address"
      ;;
    *.alloclog)
      # debug flags
      flags="$CPPFLAGS -O0 -g -D DUMB_ALLOC -D ALLOC_LOG"
      ;;
    *.dbg)
      # debug flags
      flags="$CPPFLAGS -O0 -g"
      ;;
  esac

  # Hack to remove optview::Exec
  case $out in
    *osh_parse*)
      flags="$flags -D OSH_PARSE"
      ;;
    *osh_eval*)
      flags="$flags -D OSH_EVAL"
      ;;
  esac

  # Avoid memset().  TODO: remove this hack!
  flags="$flags -D NO_GC_HACK"

  if false; then
    # With new Clang:
    # - 5.3 seconds for osh_eval.cc
    # - 1.3 seconds for syntax_asdl.cc -- hm how to speed this up
    # - 14ms for cpp/signal_.cc, a tiny file
    # So yeah parallelizing this is good.  TODO: use Ninja

    mkdir -p _build/obj

    local -a objects=()
    for src in "$@"; do

      local obj=_build/obj/$(basename $src .cc).o

      echo "--- $src"

      # need -fPIC for some reason
      time $CXX $flags \
        -fPIC \
        -ftime-trace \
        -I . \
        -I mycpp \
        -I cpp \
        -I _build/cpp \
        -I _devbuild/gen \
        -o $obj \
        -c $src \

      objects=("${objects[@]}" "$obj")
    done

    echo "=== link ${objects[@]}"
    time cc -o $out "${objects[@]}" $link_flags -lstdc++

  else
    # flags are split
    $CXX $flags \
      -I . \
      -I mycpp \
      -I cpp \
      -I _build/cpp \
      -I _devbuild/gen \
      -o $out \
      "$@" \
      $link_flags \
      -lstdc++
  fi
}

cxx=''         # MUTABLE GLOBAL compiler
flags=''       # MUTABLE GLOBAL compile flags
link_flags=''  # MUTABLE GLOBAL link flags

setglobal_cxx() {
  local compiler=$1

  case $compiler in 
    (cxx)   cxx='c++'    ;;
    (clang) cxx=$CLANGXX ;;
  esac
}


setglobal_compile_flags() {
  local variant=$1
  local dotd=${2:-}

  flags="
    $CPPFLAGS
    -I . 
    -I mycpp 
    -I cpp 
    -I _build/cpp 
    -I _devbuild/gen 
  "

  case $variant in
    (dbg)
      # debug flags
      flags="$flags -O0 -g"
      ;;
    (asan)
      # Note: Clang's ASAN doesn't like DUMB_ALLOC, but GCC is fine with it
      flags="$flags -O0 -g -fsanitize=address"
      ;;
    (opt)
      flags="$flags -O2 -g -D DUMB_ALLOC"
      # To debug crash with 8 byte alignment
      #flags="$CPPFLAGS -O0 -g -D DUMB_ALLOC -D ALLOC_LOG"
      ;;

    (uftrace)
      # -O0 creates a A LOT more data.  But sometimes we want to see the
      # structure of the code.
      # vector::size(), std::forward, len(), etc. are not inlined.
      # Also List::List, Tuple2::at0, etc.
      #local opt='-O2'
      local opt='-O0'

      # Do we want DUMB_ALLOC here?
      flags="$flags $opt -g -pg"
      ;;

    (malloc)
      flags="$flags -O2 -g"
      ;;
    (tcmalloc)
      flags="$flags -O2 -g -D TCMALLOC"
      ;;
    (alloclog)
      # debug flags
      flags="$flags -O0 -g -D DUMB_ALLOC -D ALLOC_LOG"
      ;;
  esac

  # needed to strip unused symbols
  # https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld
  #
  # Hm this still does not produce as small a binary as compiling everything in
  # one go!
  #
  # one CXX:                       1.38 MB 
  # multiple CXX with these flags: 1.84 MB
  # multiple CXX without:          2.04 MB

  # Also -flto makes it bigger?  wtf.

  flags="$flags -fdata-sections -ffunction-sections"

  # Avoid memset().  TODO: remove this hack!
  flags="$flags -D NO_GC_HACK"

  # hack for osh_eval_stubs.h
  flags="$flags -D OSH_EVAL"

  # https://ninja-build.org/manual.html#ref_headers
  if test -n "$dotd"; then
    flags="$flags -MD -MF $dotd"
  fi

  # external
  local more_flags=${CXXFLAGS:-}
  if test -n "$more_flags"; then
    flags="$flags $more_flags"
  fi

  # TODO: make a variant for this
  # flags="$flags -ftime-trace"

}

setglobal_link_flags() {
  local variant=$1

  case $variant in
    (tcmalloc)
      link_flags='-ltcmalloc'
      ;;
    (asan)
      link_flags='-fsanitize=address'
      ;;
  esac

  link_flags="$link_flags -Wl,--gc-sections "
}

compile-one() {
  ### Compile one translation unit.  Invoked by build.ninja

  # Supports CXXFLAGS

  local compiler=$1
  local variant=$2
  local in=$3
  local out=$4
  local dotd=${5:-}  # optional .d file

  setglobal_compile_flags "$variant" "$dotd"

  if test $compiler = 'clang'; then
    # mutate global
    flags="$flags -fPIC"  # clang needs -fPIC?
  fi

  setglobal_cxx $compiler

  "$cxx" $flags -o "$out" -c "$in"
}

link() {
  ### Link oil-native.  Invoked by build.ninja

  local compiler=$1
  local variant=$2
  local out=$3
  shift 3
  # rest are inputs

  setglobal_link_flags $variant

  setglobal_cxx $compiler

  "$cxx" -o "$out" $link_flags "$@"
}

compile-and-link() {
  local compiler=$1
  local variant=$2
  local out=$3
  shift 3

  setglobal_compile_flags "$variant" ""

  setglobal_link_flags $variant

  setglobal_cxx $compiler

  "$cxx" -o "$out" $flags "$@" $link_flags
}


# what osh_eval.cc needs to compile
readonly -a DEPS_CC=(
    cpp/core_pyos.cc \
    cpp/core_pyutil.cc \
    cpp/frontend_flag_spec.cc \
    cpp/frontend_match.cc \
    cpp/frontend_tdop.cc \
    cpp/osh_arith_parse.cc \
    cpp/osh_bool_stat.cc \
    cpp/pgen2_parse.cc \
    cpp/pylib_os_path.cc \
    _build/cpp/runtime_asdl.cc \
    _build/cpp/syntax_asdl.cc \
    _build/cpp/hnode_asdl.cc \
    _build/cpp/id_kind_asdl.cc \
    _build/cpp/consts.cc \
    _build/cpp/arith_parse.cc \
    _build/cpp/arg_types.cc \
    cpp/dumb_alloc.cc \
    cpp/fcntl_.cc \
    cpp/posix.cc \
    cpp/signal_.cc \
    cpp/libc.cc \
)

readonly -a GC_RUNTIME=( mycpp/{gc_heap,mylib2,my_runtime}.cc )

readonly -a OLD_RUNTIME=( mycpp/{gc_heap,mylib}.cc )

compile-slice() {
  ### Build done outside ninja in _bin/

  local name=${1:-osh_eval}
  # Add -opt to make it opt
  local suffix=${2:-.dbg}

  shift 2

  mkdir -p _bin

  local -a runtime
  if test -n "${GC:-}"; then
    # Not ready for this yet.  Need list_contains() etc.
    runtime=( "${GC_RUNTIME[@]}" )
  else
    runtime=( "${OLD_RUNTIME[@]}" )
  fi

  # Note: can't use globs here because we have _test.cc
  time compile _bin/$name$suffix _build/cpp/${name}.cc \
    "${runtime[@]}" "${DEPS_CC[@]}" \
    "$@"
}

ninja-compile() {
  # Invoked by ninja (also in _bin/)

  local in=$1
  local out=$2

  local -a runtime
  if test -n "${GC:-}"; then
    # Not ready for this yet.  Need list_contains() etc.
    runtime=( "${GC_RUNTIME[@]}" )
  else
    runtime=( "${OLD_RUNTIME[@]}" )
  fi

  # Note: can't use globs here because we have _test.cc
  time compile $out $in \
    "${runtime[@]}" "${DEPS_CC[@]}"
}

strip_() {
  ### Invoked by ninja

  local in=$1
  local stripped=$2
  local symbols=$3

  strip -o $stripped $in

  objcopy --only-keep-debug $in $symbols
  objcopy --add-gnu-debuglink=$symbols $stripped
}

if test $(basename $0) = 'native-steps.sh'; then
  "$@"
fi
