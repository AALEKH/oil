#!/usr/bin/env python2
"""
build/native_graph.py

oil-native build.

_build/   # input source
  cpp/
    osh_eval.{h,cc}
  obj/
    asan/
      osh_eval.o
      osh_eval.d     # dependency file
      osh_eval.json  # -ftime-trace MAYBE
    dbg/
    opt/

_bin/   # output binaries
  gcc/
    osh_eval.{asan,dbg,opt}
    osh_eval.{opt.stripped,symbols}
  clang/
    osh_eval.{asan,dbg,opt,...}
    osh_eval.{opt.stripped,symbols}

Runtime options:

  CXX          override system GCC with Clang
  FTIME_TRACE  genreate .json files

Other dimensions:
  gcc vs. clang -- or system vs. clang -- then you can compare them?

  _build/bin/cxx/osh_eval.dbg
  _build/bin/clang/osh_eval.dbg

GC vs. no GC -- two runtimes

TODO

- .d dependencies
- generate shell script

- delete compile-slice and fix other entry points in build/native.sh

"""

from __future__ import print_function

import os
import sys

sys.path.append('vendor')
import ninja_syntax


def log(msg, *args):
  if args:
    msg = msg % args
  print(msg, file=sys.stderr)


DEPS_CC = [
    'cpp/core_pyos.cc',
    'cpp/core_pyutil.cc',
    'cpp/frontend_flag_spec.cc',
    'cpp/frontend_match.cc',
    'cpp/frontend_tdop.cc',
    'cpp/osh_arith_parse.cc',
    'cpp/osh_bool_stat.cc',
    'cpp/pgen2_parse.cc',
    'cpp/pylib_os_path.cc',
    'cpp/dumb_alloc.cc',
    'cpp/fcntl_.cc',
    'cpp/posix.cc',
    'cpp/signal_.cc',
    'cpp/libc.cc',

    # generated
    '_build/cpp/arg_types.cc',
    '_build/cpp/arith_parse.cc',
    '_build/cpp/consts.cc',
    '_build/cpp/osh_eval.cc',

    # ASDL generated
    '_build/cpp/runtime_asdl.cc',
    '_build/cpp/syntax_asdl.cc',
    '_build/cpp/hnode_asdl.cc',
    '_build/cpp/id_kind_asdl.cc',
]

# Note: also appears in mycpp/build_graph.py
GC_RUNTIME = [
    'mycpp/gc_heap.cc',
    'mycpp/mylib2.cc',
    'mycpp/my_runtime.cc',
]

OLD_RUNTIME = [
    'mycpp/gc_heap.cc',  # We need this?
    'mycpp/mylib.cc',
]



def NinjaGraph(n):

  n.comment('Build oil-native')
  n.comment('Generated by %s.' % os.path.basename(__file__))
  n.newline()

  # Compile one translation unit
  n.rule('cxx-oil',
         command='build/native-steps.sh cxx-oil $in $out $out.d',
         depfile='$out.d',
         description='cxx-oil $in $out')
  n.newline()

  # Link objects together
  n.rule('link',
         command='build/native-steps.sh link $out $in',
         description='link $out $in')
  n.newline()

  # 1 input and 2 outputs
  n.rule('strip',
         command='build/native-steps.sh strip_ $in $out',
         description='strip $in $out')
  n.newline()

  if 0:
    phony = {
        'osh-eval': [],  # build all osh-eval
        'strip': [],
    }

  binaries = []
  for variant in [
      'dbg', 'opt', 'asan', 'alloclog', 'malloc', 'uftrace',
      # leave out tcmalloc since it requires system libs to be installed
      # 'tcmalloc'
      ]:

    #
    # Compile objects
    #

    objects = []
    for src in DEPS_CC + OLD_RUNTIME:
      # e.g. _build/obj/dbg/posix.o
      base_name, _ = os.path.splitext(os.path.basename(src))

      obj = '_build/obj/%s/%s.o' % (variant, base_name)
      objects.append(obj)

      n.build(obj, 'cxx-oil', src,
              variables=[('variant', variant)])
      n.newline()

    b = '_bin/osh_eval.%s' % variant
    binaries.append(b)

    #
    # Link objects into binary
    #

    n.build(b, 'link', objects,
            variables=[('variant', variant)])
    n.newline()

    # Strip the .opt binary
    if variant == 'opt':
      stripped = b + '.stripped'
      symbols = b + '.symbols'
      n.build([stripped, symbols], 'strip', [b],
              variables=[('variant', variant)])
      n.newline()
      #phony['strip'].append(stripped)
      binaries.append(stripped)

  n.default(['_bin/osh_eval.dbg'])

  # All groups
  n.build(['all'], 'phony', binaries)


def ShellFunctions(f):
  """
  Build dbg or opt
  """
  print('source build/native-steps.sh', file=f)
  print('', file=f)

  for variant in ['dbg', 'opt']:
    print('%s() {' % variant, file=f)
    print('  ### Compile %s build of oil-native' % variant, file=f)
    print('', file=f)

    print('  mkdir -p _build/obj/%s' % variant, file=f)
    print('', file=f)

    objects = []
    for src in DEPS_CC + OLD_RUNTIME:
      # e.g. _build/obj/dbg/posix.o
      base_name, _ = os.path.splitext(os.path.basename(src))

      obj = '_build/obj/%s/%s.o' % (variant, base_name)
      objects.append(obj)

      print('  cxx-oil %s %s' % (src, obj), file=f)

    print('', file=f)

    b = '_bin/osh_eval.%s' % variant
    # note: can't have spaces in filenames
    print('  link %s %s' % (b, ' '.join(objects)), file=f)
    print('', file=f)

    # Strip opt binary
    if variant == 'opt':
      stripped = b + '.stripped'
      print('  strip -o %s %s' % (stripped, b), file=f)
      print('  ls -l %s' % stripped, file=f)
      print('', file=f)
    else:
      print('  ls -l %s' % b, file=f)
      print('', file=f)

    print('}', file=f)
    print('', file=f)

  # TODO: print better help
  print('"$@"', file=f)


def main(argv):
  try:
    action = argv[1]
  except IndexError:
    action = 'ninja'

  if action == 'ninja':
    out = 'build.ninja'
    n = ninja_syntax.Writer(open(out, 'w'))
    NinjaGraph(n)
    log('%s: Wrote %s', argv[0], out)

  elif action == 'shell':
    out = '_build/oil-native.sh'
    with open(out, 'w') as f:
      print('# Generated by %s' % argv[0], file=f)
      print('', file=f)

      ShellFunctions(f)
    log('%s: Wrote %s', argv[0], out)

  else:
    raise RuntimeError('Invalid action %r' % action)


if __name__ == '__main__':
  try:
    main(sys.argv)
  except RuntimeError as e:
    print('FATAL: %s' % e, file=sys.stderr)
    sys.exit(1)
