#!/usr/bin/env python2
"""
build/native_graph.py

oil-native build.

_build/   # input source
  cpp/
    osh_eval.{h,cc}
  obj/
    # The obj folder is a 2-tuple {cxx,clang}-{dbg,opt,asan ...} (separate is implied)

    cxx-asan/
      osh_eval.o
      osh_eval.d     # dependency file
      osh_eval.json  # -ftime-trace MAYBE
    cxx-dbg/
    cxx-opt/

_bin/   # output binaries
  # The _bin folder is a 3-tuple
  {cxx,clang}-{dbg,opt,asan ...}-{separate,together}
    osh_eval

  _bin/cxx-opt-together/osh_eval.stripped   # this is the main one

  cxx-opt-together/
    osh_eval
    osh_eval.stripped
  cxx-opt-separate/
    osh_eval
    osh_eval.{stripped,symbols}

Runtime options:

  CXX          override system GCC with Clang
  FTIME_TRACE  genreate .json files

TODO

- Do 'together' build, with 'compile-and-link' rule

- Rules for generated code
  - for build.ninja
  - _build/oil-native.sh
- Should you make a bloaty report for the separate build too?

- delete compile-slice, and replace with _build/oil-native.sh
  - fix other entry points in build/native.sh
"""

from __future__ import print_function

import os
import sys

sys.path.append('vendor')
import ninja_syntax


def log(msg, *args):
  if args:
    msg = msg % args
  print(msg, file=sys.stderr)


DEPS_CC = [
    'cpp/core_pyos.cc',
    'cpp/core_pyutil.cc',
    'cpp/frontend_flag_spec.cc',
    'cpp/frontend_match.cc',
    'cpp/frontend_tdop.cc',
    'cpp/osh_arith_parse.cc',
    'cpp/osh_bool_stat.cc',
    'cpp/pgen2_parse.cc',
    'cpp/pylib_os_path.cc',
    'cpp/dumb_alloc.cc',
    'cpp/fcntl_.cc',
    'cpp/posix.cc',
    'cpp/signal_.cc',
    'cpp/libc.cc',

    # generated
    '_build/cpp/arg_types.cc',
    '_build/cpp/arith_parse.cc',
    '_build/cpp/consts.cc',
    '_build/cpp/osh_eval.cc',

    # ASDL generated
    '_build/cpp/runtime_asdl.cc',
    '_build/cpp/syntax_asdl.cc',
    '_build/cpp/hnode_asdl.cc',
    '_build/cpp/id_kind_asdl.cc',
]

# Note: also appears in mycpp/build_graph.py
GC_RUNTIME = [
    'mycpp/gc_heap.cc',
    'mycpp/mylib2.cc',
    'mycpp/my_runtime.cc',
]

OLD_RUNTIME = [
    'mycpp/gc_heap.cc',  # We need this?
    'mycpp/mylib.cc',
]



def NinjaGraph(n):

  n.comment('Build oil-native')
  n.comment('Generated by %s.' % os.path.basename(__file__))
  n.newline()

  # 'together'b uild
  n.rule('compile-and-link',
         # multiple outputs
         command='build/native-steps.sh compile-and-link $compiler $variant $out $in',
         description='compile-and-link $compiler $variant $out $in')
  n.newline()

  # Compile one translation unit
  n.rule('compile-one',
         command='build/native-steps.sh compile-one $compiler $variant $in $out $out.d',
         depfile='$out.d',
         description='compile-one $compiler $variant $in $out')
  n.newline()

  # Link objects together
  n.rule('link',
         command='build/native-steps.sh link $compiler $variant $out $in',
         description='link $compiler $variant $out $in')
  n.newline()

  # 1 input and 2 outputs
  n.rule('strip',
         command='build/native-steps.sh strip_ $in $out',
         description='strip $in $out')
  n.newline()

  if 0:
    phony = {
        'osh-eval': [],  # build all osh-eval
        'strip': [],
    }

  binaries = []

  for compiler in ['cxx', 'clang']:
    for variant in [
        'dbg', 'opt', 'asan', 'alloclog', 'malloc', 'uftrace',
        # leave out tcmalloc since it requires system libs to be installed
        # 'tcmalloc'
        ]:

      ninja_vars = [('compiler', compiler), ('variant', variant)]

      #
      # TOGETHER
      #

      bin_together = '_bin/%s-%s-together/osh_eval' % (compiler, variant)
      binaries.append(bin_together)

      sources = DEPS_CC + OLD_RUNTIME
      n.build(bin_together, 'compile-and-link', sources, variables=ninja_vars)
      n.newline()

      #
      # SEPARATE: Compile objects
      #

      objects = []
      for src in sources:
        # e.g. _build/obj/dbg/posix.o
        base_name, _ = os.path.splitext(os.path.basename(src))

        obj = '_build/obj/%s-%s-separate/%s.o' % (compiler, variant, base_name)
        objects.append(obj)

        n.build(obj, 'compile-one', src, variables=ninja_vars)
        n.newline()

      bin_separate = '_bin/%s-%s-separate/osh_eval' % (compiler, variant)
      binaries.append(bin_separate)

      #
      # SEPARATE: Link objects into binary
      #

      n.build(bin_separate, 'link', objects, variables=ninja_vars)
      n.newline()

      # Strip the .opt binary
      if variant == 'opt':
        for b in [bin_together, bin_separate]:
          stripped = b + '.stripped'
          symbols = b + '.symbols'
          n.build([stripped, symbols], 'strip', [b])
          n.newline()

          binaries.append(stripped)

  n.default(['_bin/cxx-dbg-separate/osh_eval'])

  # All groups
  n.build(['all'], 'phony', binaries)


def ShellFunctions(f):
  """
  Build dbg or opt
  """
  print('source build/native-steps.sh', file=f)
  print('', file=f)

  for variant in ['dbg', 'opt']:
    print('%s() {' % variant, file=f)
    print('  ### Compile %s build of oil-native' % variant, file=f)
    print('', file=f)

    print('  mkdir -p _build/obj/%s' % variant, file=f)
    print('', file=f)

    objects = []
    for src in DEPS_CC + OLD_RUNTIME:
      # e.g. _build/obj/dbg/posix.o
      base_name, _ = os.path.splitext(os.path.basename(src))

      obj = '_build/obj/%s/%s.o' % (variant, base_name)
      objects.append(obj)

      print('  compile-one %s %s' % (src, obj), file=f)

    print('', file=f)

    b = '_bin/osh_eval.%s' % variant
    # note: can't have spaces in filenames
    print('  link %s %s' % (b, ' '.join(objects)), file=f)
    print('', file=f)

    # Strip opt binary
    if variant == 'opt':
      stripped = b + '.stripped'
      print('  strip -o %s %s' % (stripped, b), file=f)
      print('  ls -l %s' % stripped, file=f)
      print('', file=f)
    else:
      print('  ls -l %s' % b, file=f)
      print('', file=f)

    print('}', file=f)
    print('', file=f)

  # TODO: print better help
  print('"$@"', file=f)


def main(argv):
  try:
    action = argv[1]
  except IndexError:
    action = 'ninja'

  if action == 'ninja':
    out = 'build.ninja'
    n = ninja_syntax.Writer(open(out, 'w'))
    NinjaGraph(n)
    log('%s: Wrote %s', argv[0], out)

  elif action == 'shell':
    out = '_build/oil-native.sh'
    with open(out, 'w') as f:
      print('# Generated by %s' % argv[0], file=f)
      print('', file=f)

      ShellFunctions(f)
    log('%s: Wrote %s', argv[0], out)

  else:
    raise RuntimeError('Invalid action %r' % action)


if __name__ == '__main__':
  try:
    main(sys.argv)
  except RuntimeError as e:
    print('FATAL: %s' % e, file=sys.stderr)
    sys.exit(1)
