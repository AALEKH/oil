#!/usr/bin/env python2
"""
build/ninja_main.py - invoked by ./NINJA-config.sh

Code Layout:

  build/
    # TODO: rename to "steps"
    ninja-rules-py.sh
    ninja-rules-cpp.sh
  cpp/
    NINJA_subgraph.py
  mycpp/
    NINJA_subgraph.py  # This file describes dependencies programmatically
    TEST.sh            # test driver for unit tests and examples

    examples/
      cgi.py
      varargs.py
      varargs_preamble.h

Output Layout:

  _gen/
    bin/ 
      osh_eval.mycpp.{h,cc}
    mycpp/
      examples/
        cgi.mycpp.cc
        cgi_raw.mycpp.cc
        cgi.pea.cc
        cgi_raw.pea.cc
        expr.asdl.{h,cc}

  _build/
    NINJA/  # part of the Ninja graph
      asdl.asdl_main/
        all-pairs.txt
        deps.txt

    obj/
      # The obj folder is a 2-tuple {cxx,clang}-{dbg,opt,asan ...}
      cxx-dbg/
        bin/
          osh_eval.mycpp.o
          osh_eval.mycpp.d     # dependency file
          osh_eval.mycpp.json  # when -ftime-trace is passed
        mycpp/
          gc_heap_test.o  # not translated
          gc_builtins.o   
        _gen/
          mycpp/
            examples/
              cgi.mycpp.o
              cgi.mycpp.o.d
              cgi.pea.o
              cgi.pea.o.d
              expr.asdl.o
              expr.asdl.o.d
      cxx-gcevery/
      cxx-opt/
      clang-coverage/

    preprocessed/
      cxx-dbg/
        cpp/
          leaky_stdlib.cc
      cxx-dbg.txt  # line counts


  _bin/

    # These are the code generators.  TODO: move to _bin/PORT/asdl/asdl_main
    shwrap/
      asdl_main
      mycpp_main
      lexer_gen
      ...

    # The _bin folder is a 3-tuple {cxx,clang}-{dbg,opt,asan ...}-{,sh}
    cxx-opt/
      osh_eval
      osh_eval.stripped              # The end user binary, with top_level = True
      osh_eval.symbols

      mycpp/
        examples/
          cgi.mycpp
          cgi.mycpp.stripped
          cgi.pea
          cgi.pea.stripped
        gc_heap_test

    cxx-opt-sh/                      # with shell script
      cxx-gcevery/
        mycpp/
          gc_heap_test

    clang-coverage/

  _test/
    tasks/        # *.txt and *.task.txt for .wwz
      typecheck/  # optionally run
      test/       # py, gcevery, asan, opt
      benchmark/

      # optionally logged?
      translate/
      compile/

# More

  # C code shared with the Python build
  # eventually this can be moved into Ninja
  _devbuild/
    gen/
      osh-lex.h
      osh-types.h
      id.h
      grammar_nt.h

      runtime_asdl.py
"""
from __future__ import print_function

import cStringIO
from glob import glob
import os
import sys

from build import ninja_lib
from build.ninja_lib import log

from vendor import ninja_syntax


# The file Ninja runs by default.
BUILD_NINJA = 'build.ninja'


def TarballManifest(cc_sources):
  names = []

  # Text
  names.extend([
    'LICENSE.txt',
    'README-native.txt',
    ])

  # Code we know about
  names.extend(cc_sources)
  names.extend(cpp_subgraph.GENERATED_H)
  names.extend(cpp_subgraph.ASDL_H)

  names.extend(glob('mycpp/*.h'))

  # TODO: crawl headers
  names.extend(glob('cpp/*.h'))

  # TODO: Put these in Ninja.
  names.extend(glob('_gen/frontend/*.h'))
  names.extend(glob('_gen/oil_lang/*.h'))

  # ONLY the headers
  names.extend(glob('prebuilt/*/*.h'))

  # Build scripts
  names.extend([
    'build/common.sh',
    'build/native.sh',
    'build/ninja-rules-cpp.sh',
    'mycpp/common.sh',

    # Generated
    '_build/oil-native.sh',
    ])

  for name in names:
    print(name)


def ShellFunctions(cc_sources, f, argv0):
  """
  Generate a shell script that invokes the same function that build.ninja does
  """
  print('''\
#!/usr/bin/env bash
#
# _build/oil-native.sh - generated by %s
#
# Usage
#   _build/oil-native COMPILER? VARIANT? SKIP_REBUILD?
#
#   COMPILER: 'cxx' for system compiler, or 'clang' [default cxx]
#   VARIANT: 'dbg' or 'opt' [default dbg]
#   SKIP_REBUILD: if non-empty, checks if the output exists before building
#
# Could run with /bin/sh, but use bash for now, bceause dash has bad errors messages!
#!/bin/sh

. build/ninja-rules-cpp.sh

main() {
  ### Compile oil-native into _bin/$compiler-$variant-sh/ (not with ninja)

  local compiler=${1:-cxx}   # default is system compiler
  local variant=${2:-opt}    # default is optimized build
  local skip_rebuild=${3:-}  # if the output exists, skip build'

''' % (argv0), file=f)

  out = '_bin/$compiler-$variant-sh/osh_eval'
  print('  local out=%s' % out, file=f)

  print('''\
  if test -n "$skip_rebuild" && test -f "$out"; then
    echo
    echo "$0: SKIPPING build because $out exists"
    echo
    return
  fi

  echo
  echo "$0: Building oil-native: $out"
  echo

  mkdir -p "_build/obj/$compiler-$variant-sh" "_bin/$compiler-$variant-sh"
''', file=f)

  objects = []
  for src in cc_sources:
    # e.g. _build/obj/dbg/posix.o
    base_name, _ = os.path.splitext(os.path.basename(src))

    obj_quoted = '"_build/obj/$compiler-$variant-sh/%s.o"' % base_name
    objects.append(obj_quoted)

    print("  echo 'CXX %s'" % src, file=f)
    print('  compile_one "$compiler" "$variant" "" \\', file=f)
    print('    %s %s' % (src, obj_quoted), file=f)

  print('', file=f)

  print('  echo "LINK $out"', file=f)
  # note: can't have spaces in filenames
  print('  link "$compiler" "$variant" "$out" \\', file=f)
  # put each object on its own line, and indent by 4
  print('    %s' % (' \\\n    '.join(objects)), file=f)
  print('', file=f)

  # Strip opt binary
  # TODO: provide a way for the user to get symbols?

  print('''\
  if test "$variant" = opt; then
    strip -o "$out.stripped" "$out"
  fi
}

main "$@"
''', file=f)


def Preprocessed(n, cc_sources):
  # See how much input we're feeding to the compiler.  Test C++ template
  # explosion, e.g. <unordered_map>
  #
  # Limit to {dbg,opt} so we don't generate useless rules.  Invoked by
  # metrics/source-code.sh

  pre_matrix = [
      ('cxx', 'dbg'),
      ('cxx', 'opt'),
      ('clang', 'dbg'),
      ('clang', 'opt'),
  ]
  for compiler, variant in pre_matrix:
    preprocessed = []
    for src in cc_sources:
      # e.g. _build/preprocessed/cxx-dbg/mycpp/gc_heap.cc
      rel_path, _ = os.path.splitext(src)
      pre = '_build/preprocessed/%s-%s/%s.cc' % (compiler, variant, rel_path)
      preprocessed.append(pre)

    # Summary file
    n.build('_build/preprocessed/%s-%s.txt' % (compiler, variant),
            'line_count',
            preprocessed)
    n.newline()


def InitSteps(n):
  """Wrappers for build/ninja-rules-*.sh

  Some of these are defined in mycpp/NINJA_subgraph.py.  Could move them here.
  """

  # Preprocess one translation unit
  n.rule('preprocess',
         # compile_one detects the _build/preprocessed path
         command='build/ninja-rules-cpp.sh compile_one $compiler $variant $more_cxx_flags $in $out',
         description='PP $compiler $variant $more_cxx_flags $in $out')
  n.newline()

  n.rule('line_count',
         command='build/ninja-rules-cpp.sh line_count $out $in',
         description='line_count $out $in')
  n.newline()

  # Compile one translation unit
  n.rule('compile_one',
         command='build/ninja-rules-cpp.sh compile_one $compiler $variant $more_cxx_flags $in $out $out.d',
         depfile='$out.d',
         # no prefix since the compiler is the first arg
         description='$compiler $variant $more_cxx_flags $in $out')
  n.newline()

  # Link objects together
  n.rule('link',
         command='build/ninja-rules-cpp.sh link $compiler $variant $out $in',
         description='LINK $compiler $variant $out $in')
  n.newline()

  # 1 input and 2 outputs
  n.rule('strip',
         command='build/ninja-rules-cpp.sh strip_ $in $out',
         description='STRIP $in $out')
  n.newline()

  n.rule('write-shwrap',
         # $in must start with main program
         command='build/ninja-rules-py.sh write-shwrap $template $out $in',
         description='make-pystub $out $in')
  n.newline()


  #
  # Code generators
  #

  n.rule('asdl-cpp',
         command='_bin/shwrap/asdl_main $action $asdl_flags $in $out_prefix $debug_mod',
         description='asdl_main $action $asdl_flags $in $out_prefix $debug_mod')
  n.newline()

  n.rule('consts-gen',
         command='_bin/shwrap/consts_gen $action $out_prefix',
         description='consts_gen $action $out_prefix')

  n.rule('flag-gen',
         command='_bin/shwrap/flag_gen $action $out_prefix',
         description='flag_gen $action $out_prefix')

  n.rule('option-gen',
         command='_bin/shwrap/option_gen $action $out_prefix',
         description='consts_gen $action $out_prefix')

  n.rule('optview-gen',
         # uses shell style
         command='_bin/shwrap/optview_gen > $out',
         description='optview_gen > $out')

  n.rule('arith-parse-gen',
         # uses shell style
         command='_bin/shwrap/arith_parse_gen > $out',
         description='arith-parse-gen > $out')

  prefix = '_gen/frontend/id_kind.asdl'
  n.build([prefix + '.h', prefix + '.cc'], 'consts-gen', [],
          implicit=['_bin/shwrap/consts_gen'],
          variables=[
            ('out_prefix', prefix),
            ('action', 'cpp'),
          ])
  n.newline()

  n.rule('signal-gen',
         command='_bin/shwrap/signal_gen $action $out_prefix',
         description='signal_gen $action $out_prefix')

  # Similar to above
  prefix = '_gen/frontend/consts'
  n.build([prefix + '.h', prefix + '.cc'], 'consts-gen', [],
          implicit=['_bin/shwrap/consts_gen'],
          variables=[
            ('out_prefix', prefix),
            ('action', 'cpp-consts'),
          ])
  n.newline()

  prefix = '_gen/frontend/arg_types'
  n.build([prefix + '.h', prefix + '.cc'], 'flag-gen', [],
          implicit=['_bin/shwrap/flag_gen'],
          variables=[
            ('out_prefix', prefix),
            ('action', 'cpp'),
          ])
  n.newline()

  prefix = '_gen/frontend/option.asdl'
  # no .cc file
  n.build([prefix + '.h'], 'option-gen', [],
          implicit=['_bin/shwrap/option_gen'],
          variables=[
            ('out_prefix', prefix),
            ('action', 'cpp'),
          ])
  n.newline()

  n.build(['_gen/core/optview.h'], 'optview-gen', [],
          implicit=['_bin/shwrap/optview_gen'])
  n.newline()

  n.build(['_gen/osh/arith_parse.cc'], 'arith-parse-gen', [],
          implicit=['_bin/shwrap/arith_parse_gen'])
  n.newline()

  prefix = '_gen/frontend/signal'
  n.build([prefix + '.h', prefix + '.cc'], 'signal-gen', [],
          implicit=['_bin/shwrap/signal_gen'],
          variables=[
            ('out_prefix', prefix),
            ('action', 'cpp'),
          ])
  n.newline()


def InitCodeGen(ru):
  # All the code generators from NINJA-config.sh
  #
  # TODO: could be moved into frontend, core/, etc.
  ru.shwrap_py('core/optview_gen.py')
  ru.shwrap_py('frontend/consts_gen.py')
  ru.shwrap_py('frontend/flag_gen.py')
  ru.shwrap_py('frontend/lexer_gen.py')
  ru.shwrap_py('frontend/option_gen.py')
  ru.shwrap_py('frontend/signal_gen.py')
  ru.shwrap_py('oil_lang/grammar_gen.py')
  ru.shwrap_py('osh/arith_parse_gen.py')

  ru.shwrap_py(
      'mycpp/mycpp_main.py',
      deps_base_dir = 'prebuilt/ninja',
      template = 'mycpp')

  ru.shwrap_py(
      'pea/pea_main.py',
      deps_base_dir = 'prebuilt/ninja',
      template = 'pea')


def main(argv):
  try:
    action = argv[1]
  except IndexError:
    action = 'ninja'

  if action == 'ninja':
    f = open(BUILD_NINJA, 'w')
  else:
    f = cStringIO.StringIO()  # thrown away

  n = ninja_syntax.Writer(f)
  ru = ninja_lib.Rules(n)

  ru.comment('InitSteps()')
  InitSteps(n)

  ru.comment('InitCodeGen()')
  InitCodeGen(ru)

  #
  # Create the graph.
  #

  from asdl import NINJA_subgraph as asdl_subgraph
  from core import NINJA_subgraph as core_subgraph
  from cpp import NINJA_subgraph as cpp_subgraph
  from frontend import NINJA_subgraph as frontend_subgraph
  from mycpp import NINJA_subgraph as mycpp_subgraph
  from prebuilt import NINJA_subgraph as prebuilt_subgraph

  asdl_subgraph.NinjaGraph(ru)
  ru.comment('')

  core_subgraph.NinjaGraph(ru)
  ru.comment('')

  cpp_subgraph.NinjaGraph(ru)
  ru.comment('')

  frontend_subgraph.NinjaGraph(ru)
  ru.comment('')

  mycpp_subgraph.NinjaGraph(ru)
  ru.comment('')

  prebuilt_subgraph.NinjaGraph(ru)
  ru.comment('')


  # Materialize all the cc_binary() rules
  ru.WriteRules()

  # Collect sources for metrics, tarball, shell script
  cc_sources = ru.SourcesForBinary('_gen/bin/osh_eval.mycpp.cc')

  if 0:
    from pprint import pprint
    pprint(cc_sources)

  # TODO: could thin these out, not generate for unit tests, etc.
  Preprocessed(n, cc_sources)

  ru.WritePhony()

  n.default(['_bin/cxx-dbg/osh_eval'])


  if action == 'ninja':
    log('  (%s) -> %s (%d build targets)', argv[0], BUILD_NINJA,
        n.num_build_targets())

  elif action == 'shell':
    out = '_build/oil-native.sh'
    with open(out, 'w') as f:
      ShellFunctions(cc_sources, f, argv[0])
    log('  (%s) -> %s', argv[0], out)

  elif action == 'tarball-manifest':
    TarballManifest(cc_sources)

  else:
    raise RuntimeError('Invalid action %r' % action)


if __name__ == '__main__':
  try:
    main(sys.argv)
  except RuntimeError as e:
    print('FATAL: %s' % e, file=sys.stderr)
    sys.exit(1)
