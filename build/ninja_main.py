#!/usr/bin/env python2
"""
build/NINJA_main.py - invoked by ./NINJA-config.sh
"""
from __future__ import print_function

import cStringIO
from glob import glob
import os
import sys

from build import ninja_lib
from build.ninja_lib import log

from asdl import NINJA_subgraph as asdl_subgraph
from build import NINJA_subgraph as build_subgraph
from cpp import NINJA_subgraph as cpp_subgraph
from mycpp import NINJA_subgraph as mycpp_subgraph
from prebuilt import NINJA_subgraph as prebuilt_subgraph

from vendor import ninja_syntax


# The file Ninja runs by default.
BUILD_NINJA = 'build.ninja'


def TarballManifest(cc_sources):
  names = []

  # Text
  names.extend([
    'LICENSE.txt',
    'README-native.txt',
    ])

  # Code we know about
  names.extend(cc_sources)
  names.extend(cpp_subgraph.GENERATED_H)
  names.extend(cpp_subgraph.ASDL_H)

  names.extend(glob('mycpp/*.h'))

  # TODO: crawl headers
  names.extend(glob('cpp/*.h'))

  # TODO: Put these in Ninja.
  names.extend(glob('_gen/frontend/*.h'))
  names.extend(glob('_gen/oil_lang/*.h'))

  # ONLY the headers
  names.extend(glob('prebuilt/*/*.h'))

  # Build scripts
  names.extend([
    'build/common.sh',
    'build/native.sh',
    'build/ninja-rules-cpp.sh',
    'mycpp/common.sh',

    # Generated
    '_build/oil-native.sh',
    ])

  for name in names:
    print(name)


def ShellFunctions(cc_sources, f, argv0):
  """
  Generate a shell script that invokes the same function that build.ninja does
  """
  print('''\
#!/usr/bin/env bash
#
# _build/oil-native.sh - generated by %s
#
# Usage
#   _build/oil-native COMPILER? VARIANT? SKIP_REBUILD?
#
#   COMPILER: 'cxx' for system compiler, or 'clang' [default cxx]
#   VARIANT: 'dbg' or 'opt' [default dbg]
#   SKIP_REBUILD: if non-empty, checks if the output exists before building
#
# Could run with /bin/sh, but use bash for now, bceause dash has bad errors messages!
#!/bin/sh

. build/ninja-rules-cpp.sh

main() {
  ### Compile oil-native into _bin/$compiler-$variant-sh/ (not with ninja)

  local compiler=${1:-cxx}   # default is system compiler
  local variant=${2:-opt}    # default is optimized build
  local skip_rebuild=${3:-}  # if the output exists, skip build'

''' % (argv0), file=f)

  out = '_bin/$compiler-$variant-sh/osh_eval'
  print('  local out=%s' % out, file=f)

  print('''\
  if test -n "$skip_rebuild" && test -f "$out"; then
    echo
    echo "$0: SKIPPING build because $out exists"
    echo
    return
  fi

  echo
  echo "$0: Building oil-native: $out"
  echo

  mkdir -p "_build/obj/$compiler-$variant-sh" "_bin/$compiler-$variant-sh"
''', file=f)

  objects = []
  for src in cc_sources:
    # e.g. _build/obj/dbg/posix.o
    base_name, _ = os.path.splitext(os.path.basename(src))

    obj_quoted = '"_build/obj/$compiler-$variant-sh/%s.o"' % base_name
    objects.append(obj_quoted)

    print("  echo 'CXX %s'" % src, file=f)
    print('  compile_one "$compiler" "$variant" "" \\', file=f)
    print('    %s %s' % (src, obj_quoted), file=f)

  print('', file=f)

  print('  echo "LINK $out"', file=f)
  # note: can't have spaces in filenames
  print('  link "$compiler" "$variant" "$out" \\', file=f)
  # put each object on its own line, and indent by 4
  print('    %s' % (' \\\n    '.join(objects)), file=f)
  print('', file=f)

  # Strip opt binary
  # TODO: provide a way for the user to get symbols?

  print('''\
  if test "$variant" = opt; then
    strip -o "$out.stripped" "$out"
  fi
}

main "$@"
''', file=f)


def main(argv):
  try:
    action = argv[1]
  except IndexError:
    action = 'ninja'

  if action == 'ninja':
    f = open(BUILD_NINJA, 'w')
  else:
    f = cStringIO.StringIO()  # thrown away

  n = ninja_syntax.Writer(f)
  ru = ninja_lib.Rules(n)

  ### Create the graph.  TODO: Add other dirs.

  asdl_subgraph.NinjaGraph(ru)

  n.newline()
  n.newline()

  build_subgraph.NinjaGraph(ru)

  n.newline()
  n.newline()

  # //mycpp/runtime defined first
  mycpp_subgraph.NinjaGraph(ru)

  n.newline()
  n.newline()

  cpp_subgraph.NinjaGraph(ru)

  n.newline()
  n.newline()

  prebuilt_subgraph.NinjaGraph(ru)

  n.newline()
  n.newline()

  # Now collect sources for tarball and shell script
  cc_sources = ru.SourcesForBinary('_gen/bin/osh_eval.mycpp.cc')

  if action == 'ninja':
    log('  (%s) -> %s (%d build targets)', argv[0], BUILD_NINJA,
        n.num_build_targets())

  elif action == 'shell':
    out = '_build/oil-native.sh'
    with open(out, 'w') as f:
      ShellFunctions(cc_sources, f, argv[0])
    log('  (%s) -> %s', argv[0], out)

  elif action == 'tarball-manifest':
    TarballManifest(cc_sources)

  else:
    raise RuntimeError('Invalid action %r' % action)


if __name__ == '__main__':
  try:
    main(sys.argv)
  except RuntimeError as e:
    print('FATAL: %s' % e, file=sys.stderr)
    sys.exit(1)
