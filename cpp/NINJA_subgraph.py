#!/usr/bin/env python2
"""
cpp/NINJA_subgraph.py
"""

from __future__ import print_function

import os
import sys

from build import ninja_lib
from build.ninja_lib import log, ObjPath
from mycpp import NINJA_subgraph as mycpp_subgraph
from mycpp.NINJA_subgraph import GC_RUNTIME


# CPP bindings and some generated code have implicit dependencies on these headers
ASDL_H = [
    '_gen/asdl/hnode.asdl.h',
    '_gen/core/runtime.asdl.h',
    '_gen/frontend/syntax.asdl.h',
    '_gen/frontend/types.asdl.h',

    # synthetic
    '_gen/frontend/id_kind.asdl.h',
    '_gen/frontend/option.asdl.h',
]

GENERATED_H = [
    '_gen/frontend/arg_types.h',
    # NOTE: there is no cpp/arith_parse.h

    '_gen/frontend/consts.h',
    '_gen/core/optview.h',  # header only
]

def NinjaGraph(ru):
  n = ru.n

  n.comment('Generated by %s' % __name__)
  n.newline()

  ru.cc_library(
      '//cpp/leaky_core', 
      srcs = ['cpp/leaky_core.cc'],
      # No implicit deps on ASDL, but some files do
      matrix = ninja_lib.COMPILERS_VARIANTS)

  ru.cc_binary(
      'cpp/leaky_core_test.cc',
      deps = [
        '//cpp/leaky_core',
        '//mycpp/runtime',
        ],
      matrix = ninja_lib.COMPILERS_VARIANTS)

  # TODO: could split these up more, with fine-grained ASDL deps?
  ru.cc_library(
      '//cpp/leaky_bindings', 
      srcs = [
        'cpp/leaky_frontend_flag_spec.cc',
        'cpp/leaky_frontend_match.cc',
        'cpp/leaky_frontend_tdop.cc',
        'cpp/leaky_osh.cc',
        'cpp/leaky_pgen2.cc',
        'cpp/leaky_pylib.cc',
        'cpp/leaky_stdlib.cc',
        'cpp/leaky_libc.cc',
      ],
      implicit = ASDL_H + GENERATED_H,  # TODO: express as proper deps?
      matrix = ninja_lib.COMPILERS_VARIANTS)

  ru.cc_binary(
      'cpp/gc_binding_test.cc',
      deps = [
        '//cpp/leaky_bindings',
        '//mycpp/runtime',
        ],
      matrix = ninja_lib.COMPILERS_VARIANTS)

  ru.cc_binary(
      'cpp/leaky_binding_test.cc',
      deps = [
        '//cpp/leaky_bindings',
        '//cpp/leaky_core',  # could move this
        '//mycpp/runtime',
        ],
      matrix = ninja_lib.COMPILERS_VARIANTS)

  ru.cc_library(
      '//ASDL_CC',  # TODO: split these up?
      srcs = [
        '_gen/core/runtime.asdl.cc',
        '_gen/frontend/syntax.asdl.cc',
        '_gen/frontend/id_kind.asdl.cc',

        # NOT generated due to --no-pretty-print-methods
        # '_gen/frontend/types.asdl.cc',
        # '_gen/asdl/hnode.asdl.cc',
        # '_gen/frontend/option.asdl.cc',
      ],
      implicit = ASDL_H + GENERATED_H,  # TODO: express as proper deps?
      matrix = ninja_lib.COMPILERS_VARIANTS)

  ru.cc_library(
      # TODO: split these up?
      '//GENERATED_CC',
      srcs = [
        '_gen/frontend/arg_types.cc',
        '_gen/frontend/consts.cc',
        '_gen/osh/arith_parse.cc',
      ],
      implicit = ASDL_H + GENERATED_H,  # TODO: express as proper deps?
      matrix = ninja_lib.COMPILERS_VARIANTS)

  # Main program!
  ru.cc_binary(
      '_gen/bin/osh_eval.mycpp.cc',
      implicit = ASDL_H + GENERATED_H,  # TODO: express
      matrix = ninja_lib.COMPILERS_VARIANTS,
      top_level = True,  # _bin/cxx-dbg/osh_eval
      deps = [
        '//cpp/leaky_core',
        '//cpp/leaky_bindings',
        '//ASDL_CC',
        '//GENERATED_CC',
        '//mycpp/runtime',
        ]
      )

  n.newline()

  # TODO: add more variants?
  COMPILERS_VARIANTS = ninja_lib.COMPILERS_VARIANTS + [
      # note: these could be clang too
      ('cxx', 'uftrace'),
      ('cxx', 'tcmalloc'),

      ('cxx', 'dumballoc'),
      ('cxx', 'alloclog'),
  ]

  # See how much input we're feeding to the compiler.  Test C++ template
  # explosion, e.g. <unordered_map>
  #
  # Limit to {dbg,opt} so we don't generate useless rules.  Invoked by
  # metrics/source-code.sh
  cc_sources = ru.SourcesForBinary('_gen/bin/osh_eval.mycpp.cc')

  if 0:
    from pprint import pprint
    pprint(cc_sources)

  pre_matrix = [
      ('cxx', 'dbg'),
      ('cxx', 'opt'),
      ('clang', 'dbg'),
      ('clang', 'opt'),
  ]
  for compiler, variant in pre_matrix:
    preprocessed = []
    for src in cc_sources:
      # e.g. _build/preprocessed/cxx-dbg/mycpp/gc_heap.cc
      rel_path, _ = os.path.splitext(src)
      pre = '_build/preprocessed/%s-%s/%s.cc' % (compiler, variant, rel_path)
      preprocessed.append(pre)

    # Summary file
    n.build('_build/preprocessed/%s-%s.txt' % (compiler, variant),
            'line_count',
            preprocessed)
    n.newline()

  n.default(['_bin/cxx-dbg/osh_eval'])
