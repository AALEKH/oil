#!/usr/bin/env python2
"""
arg_gen.py
"""
from __future__ import print_function

import sys

from _devbuild.gen.runtime_asdl import flag_type_e, value_e
from core.util import log
from frontend import arg_def
from mycpp.mylib import tagswitch


def CString(s):
  # HACK for now
  assert '"' not in s, s
  assert '\\' not in s, s

  return '"%s"' % s


def Cpp(specs, header_f, cc_f):
  header_f.write("""\
// arg_types.h is generated by frontend/arg_gen.py

#ifndef ARG_TYPES_H
#define ARG_TYPES_H

#include "frontend_arg_def.h"  // for FlagSpec_c

namespace args {
class _Attributes;
}

class Str;  // mylib

namespace arg_types {
""")
  for spec_name in sorted(specs):
    spec = specs[spec_name]

    header_f.write("""
class %s {
 public:
  %s(args::_Attributes* attrs) {
  }
""" % (spec_name, spec_name))

    for field_name in sorted(spec.fields):
      typ = spec.fields[field_name]

      with tagswitch(typ) as case:
        if case(flag_type_e.Bool):
          header_f.write('  bool %s;\n' % field_name)

        elif case(flag_type_e.Str):
          header_f.write('  Str* %s;\n' % field_name)

    header_f.write("""\
};
""")

  header_f.write("""
extern FlagSpec_c kFlagSpecs[];

}  // namespace arg_types

#endif  // ARG_TYPES_H

""")

  cc_f.write("""\
// arg_types.cc is generated by frontend/arg_gen.py

#include "arg_types.h"

namespace arg_types {

""")

  var_names = []
  for i, spec_name in enumerate(sorted(specs)):
    spec = specs[spec_name]
    arity0_name = None
    arity1_name = None
    options_name = None
    defaults_name = None

    if spec.arity0:
      arity0_name = 'arity0_%d' % i
      c_strs = ', '.join(CString(s) for s in sorted(spec.arity0))
      cc_f.write('const char* %s[] = {%s};\n' % (arity0_name, c_strs))

    if spec.arity1:
      arity1_name = 'arity1_%d' % i
      cc_f.write('const char* %s[] = {};\n' % arity1_name)

    if spec.options:
      options_name = 'options_%d' % i
      c_strs = ', '.join(CString(s) for s in sorted(spec.options))
      cc_f.write('const char* %s[] = {%s};\n' % (options_name, c_strs))

    if spec.defaults:
      defaults_name = 'defaults_%d' % i
      cc_f.write('DefaultPair_c %s[] = {\n' % defaults_name)
      for name in sorted(spec.defaults):
        val = spec.defaults[name]
        if val.tag_() == value_e.Bool:
          d = 'True' if val.b else 'False'
        elif val.tag_() == value_e.Undef:
          d = 'Undef'
        else:
          raise AssertionError(val)

        cc_f.write('    {%s, Default_c::%s},\n' % (CString(name), d))

      cc_f.write('''\
    {},
};
''')
    var_names.append((arity0_name, arity1_name, options_name, defaults_name))
    cc_f.write('\n')

  cc_f.write('FlagSpec_c kFlagSpecs[] = {\n')

  # Now print a table
  for i, spec_name in enumerate(sorted(specs)):
    spec = specs[spec_name]
    names = var_names[i]
    cc_f.write('    { "%s", %s, %s, %s, %s },\n' % (
      spec_name,
      names[0] or 'nullptr', 
      names[1] or 'nullptr', 
      names[2] or 'nullptr', 
      names[3] or 'nullptr', 
    ))

  cc_f.write("""\
    {},
};

}  // namespace arg_types
""")


def main(argv):
  try:
    action = argv[1]
  except IndexError:
    raise RuntimeError('Action required')

  specs = arg_def.FLAG_SPEC

  for spec_name in sorted(specs):
    spec = specs[spec_name]
    spec.spec.PrettyPrint(f=sys.stderr)
    log('')
    
    log('spec.arity1 %s', spec.spec.arity1)

    log('%s', spec_name)
    #print(dir(spec))
    #print(spec.arity0)
    #print(spec.arity1)
    #print(spec.options)
    # Every flag has a default
    log('%s', spec.fields)

  if action == 'cpp':
    prefix = argv[2]

    with open(prefix + '.h', 'w') as header_f:
      with open(prefix + '.cc', 'w') as cc_f:
        Cpp(specs, header_f, cc_f)

  elif action == 'mypy':
    print("""
from frontend.args import _Attributes
from _devbuild.gen.runtime_asdl import (
   value_e, value__Bool, value__Int, value__Float, value__Str,
)
from typing import cast
""")
    for spec_name in sorted(specs):
      spec = specs[spec_name]

      print("""
class %s(object):
  def __init__(self, attrs):
    # type: (_Attributes) -> None
    flag = attrs.attrs
""" % spec_name)

      i = 0
      for field_name in sorted(spec.fields):
        typ = spec.fields[field_name]

        with tagswitch(typ) as case:
          if case(flag_type_e.Bool):
            subtype = 'Bool'
            subtype_field = 'b'  # e.g. Bool(bool b)
            mypy_type = 'bool'
            print('    self.%s = cast(value__Bool, flag[%r]).b  # type: bool' % (
              field_name, field_name))

          elif case(flag_type_e.Str):
            subtype = 'Str'
            subtype_field = 's'  # e.g. Bool(bool b)
            mypy_type = 'str'

            tmp = 'val%d' % i
            print('    %s = flag[%r]' % (tmp, field_name))
            print('    self.%s = None if %s.tag_() == value_e.Undef else cast(value__%s, %s).%s  # type: %s' % (
              field_name, tmp, subtype, tmp, subtype_field, mypy_type))
          else:
            raise AssertionError(typ)

        i += 1

      print()

  else:
    raise RuntimeError('Invalid action %r' % action)


if __name__ == '__main__':
  try:
    main(sys.argv)
  except RuntimeError as e:
    print('FATAL: %s' % e, file=sys.stderr)
    sys.exit(1)
