#!/usr/bin/env python2
"""
build_graph.py

Generates a Ninja file which uses this layout.

examples/
  cgi.py
  containers.py

_ninja/
  tasks/        # *.txt and *.task.txt for .wwz
    typecheck/  # optionally run

    # optionally logged?
    translate/
    compile/

    test/       # py, gc_debug, asan, opt
    benchmark/
    unit/

  gen/    # source

  bin/    # binaries
    examples/  # many variants
    unit/      # unit tests

Phony Targets
  test, benchmark, etc. (See phony dict below)

Also:

- .wwz archive of all the logs.
- Turn it into HTML and link to logs.  Basically just like Toil does.

Notes for Oil: 

- escape_path() in ninja_syntax seems wrong?  It should really take $ to $$.

    return word.replace('$ ', '$$ ').replace(' ', '$ ').replace(':', '$:')

  Ninja shouldn't have used $ and ALSO used shell commands (sh -c)!  Better
  solutions:

  - Spawn a process with environment variables.
  - use % for substitution instead

TODO:
- More actions:
  - assert-logs-equal: *.log.txt
    - output has size and md5sum overview?
  - strip binaries
- benchmark table: *.task.txt
  _tmp/mycpp-examples/raw/times.tsv
  cat these together, with a header file?
  you might need to split and parse the paths in R.
"""

from __future__ import print_function

import os
import sys

sys.path.append('../vendor')
import ninja_syntax


def log(msg, *args):
  if args:
    msg = msg % args
  print(msg, file=sys.stderr)


# special ones in examples.sh:
# - parse, varargs, modules (because it uses many modules)
# - lexer_main, alloc_main -- these use Oil code
# - pgen2_demo -- uses pgen2

def ShouldSkip(name):
  if name in ['pgen2_demo', 'alloc_main', 'lexer_main', 'named_args',
      'varargs']:
    return True

  # '%5d' doesn't work yet.  TODO: fix this.
  if name == 'strings':
    return True

  # TODO. expr.asdl when GC=1
  # qsn_qsn.h is incompatible
  if name == 'parse':
    return True

  # TODO: Call custom function in examples.sh!
  if name == 'modules':
    return True

  return False


def ExamplesToTest():

  filenames = os.listdir('examples')
  py = [name[:-3] for name in filenames if name.endswith('.py')]

  to_test = [name for name in py if not ShouldSkip(name)]

  return to_test


def ShouldSkipBenchmark(name):
  if name.startswith('test_'):
    return True

  if name == 'control_flow':
    # TODO: fix 8191 exceptions problem, I think caused by Alloc<ParseError>
    return True

  # BUG: Assertion failure here!
  if name == 'cartesian':
    return True

  # BUG: Different number of iterations!
  if name == 'files':
    return True

  return False


def ExamplesToBenchmark():
  to_test = ExamplesToTest()
  return [name for name in to_test if not ShouldSkipBenchmark(name)]


RUNTIME = ['my_runtime.cc', 'mylib2.cc', 'gc_heap.cc']

UNIT_TESTS = {
    'mylib_test': ['mylib.cc'],
    'gc_heap_test': ['gc_heap.cc'],
    'gc_stress_test': RUNTIME,
    'my_runtime_test': RUNTIME,
    'mylib2_test': RUNTIME,

    # lives in demo/target_lang.cc
    'target_lang': ['../cpp/dumb_alloc.cc', 'gc_heap.cc'],
}

def main(argv):
  n = ninja_syntax.Writer(open('build.ninja', 'w'))

  n.comment('Translate, compile, and test mycpp examples.')
  n.comment('Generated by %s.' % os.path.basename(__file__))
  n.newline()

  n.rule('translate',
         command='./build-steps.sh translate $in $out',
         description='translate $in $out')
  n.newline()
  n.rule('compile',
         # note: $in can be MULTIPLE files, shell-quoted
         command='./build-steps.sh compile $variant $out $in',
         description='compile $variant $in $out')
  n.newline()
  n.rule('task',
         # note: $out can be MULTIPLE FILES, shell-quoted
         command='./build-steps.sh task $in $out',
         description='task $in $out')
  n.newline()
  n.rule('typecheck',
         command='./build-steps.sh typecheck $in $out',
         description='typecheck $in $out')
  n.newline()
  n.rule('compare-logs',
         command='./build-steps.sh compare-logs $out $in',
         description='compare-logs $in $out')
  n.newline()

  to_benchmark = ExamplesToBenchmark()

  examples = ExamplesToTest()

  #examples = ['cgi', 'containers', 'fib_iter']
  #examples = ['cgi']

  # task table dimensions:
  #
  # (example, mode, variant)
  #
  # mode = test | benchmark
  # variant = gc_debug | asan | opt | py
  #
  # benchmark: opt and py (gc_debug also useful, asan too)
  # test: asan and py (gc_debug useful, asan mildly)
  #
  # Verification task depends on all benchmark and test tasks?
  # Then do {gc_debug, opt, asan} vs. py
  # To check that it works.

  phony = {
      'unit': [],
      'typecheck': [],  # optional: for debugging only.  translation does it.

      'test': [],  # test examples (across variants, including Python)
      'benchmark': [],  # benchmark examples (ditto)

      # Compare logs for test AND benchmarks?
      # This is a separate task because we have multiple variants to compare,
      # and the timing of test/benchmark tasks should NOT include comparison.
      'compare-logs': [],

      'strip': [],  # optional: strip binaries.  To see how big they are.
  }

  for test_name in sorted(UNIT_TESTS):
    cc_files = UNIT_TESTS[test_name]

    # TODO: doesn't run under pure 'asan' because of -D GC_DEBUG, etc.
    for variant in ['gc_debug']:  # , 'asan', 'opt']:
      b = '_ninja/bin/unit/%s.%s' % (test_name, variant)

      if test_name == 'target_lang':  # SPECIAL CASE
        main_cc = 'demo/target_lang.cc'
      else:
        main_cc = '%s.cc' % test_name

      n.build([b], 'compile', [main_cc] + cc_files,
              variables=[('variant', variant)])
      n.newline()

      prefix = '_ninja/tasks/unit/%s.%s' % (test_name, variant)
      task_out = '%s.task.txt' % prefix
      log_out = '%s.log.txt' % prefix
      n.build([task_out, log_out], 'task', b)
      n.newline()

      phony['unit'].append(task_out)

  to_compare = []

  for ex in examples:
    n.comment('---')
    n.comment(ex)
    n.comment('---')
    n.newline()

    # TODO: make a phony target for these, since they're not strictly necessary.
    # Translation does everything that type checking does.  Type checking only
    # is useful for debugging.
    t = '_ninja/tasks/typecheck/%s.log.txt' % ex
    n.build([t], 'typecheck', 'examples/%s.py' % ex)
    n.newline()
    phony['typecheck'].append(t)

    # Run Python.
    for mode in ['test', 'benchmark']:
      if mode == 'benchmark' and ShouldSkipBenchmark(ex):
        log('Skipping benchmark of %s', ex)
        continue

      prefix = '_ninja/tasks/%s/%s.py' % (mode, ex)
      task_out = '%s.task.txt' % prefix
      log_out = '%s.log.txt' % prefix
      n.build([task_out, log_out], 'task', 'examples/%s.py' % ex)
      n.newline()

      phony[mode].append(task_out)

    # Translate to C++
    n.build('_ninja/gen/%s.cc' % ex, 'translate', 'examples/%s.py' % ex)
    n.newline()

    # Compile and run C++.

    # TODO: Can also parameterize by CXX: Clang or GCC.
    for variant in ['gc_debug', 'asan', 'opt']:
      n.build('_ninja/bin/examples/%s.$variant' % ex,
              'compile',
              ['_ninja/gen/%s.cc' % ex] + RUNTIME,
              variables=[('variant', variant)])
      n.newline()

      # TODO:
      # These should depend on the Python log.txt?
      # And it will diff them?
      #
      # It's not just a task?
      # It's a comparison?
      # But we don't want to time that, so it should be done separately.
      # There are a lot of tiny files.

    # minimal
    MATRIX = [
        ('test', 'asan'),
        ('benchmark', 'opt'),
    ]

    # Run the binary in two ways
    for mode, variant in MATRIX:
      if mode == 'benchmark' and ShouldSkipBenchmark(ex):
        log('Skipping benchmark of %s', ex)
        continue

      task_out = '_ninja/tasks/%s/%s.%s.task.txt' % (mode, ex, variant)
      log_out = '_ninja/tasks/%s/%s.%s.log.txt' % (mode, ex, variant)
      py_log_out = '_ninja/tasks/%s/%s.py.log.txt' % (mode, ex)

      to_compare.append(log_out)
      to_compare.append(py_log_out)

      n.build([task_out, log_out], 'task',
              '_ninja/bin/examples/%s.%s' % (ex, variant))
      n.newline()

      phony[mode].append(task_out)

  # Compare the log of all examples
  out = '_ninja/compare-logs.txt'
  n.build([out], 'compare-logs', to_compare)
  n.newline()

  phony['compare-logs'].append(out)

  phony_real = []
  # Write out phony rules
  for name in sorted(phony):
    deps = phony[name]
    if deps:
      n.build([name], 'phony', deps)
      n.newline()

      phony_real.append(name)

  n.default(['unit', 'test', 'benchmark'])

  # All groups
  n.build(['all'], 'phony', phony_real)


if __name__ == '__main__':
  try:
    main(sys.argv)
  except RuntimeError as e:
    print('FATAL: %s' % e, file=sys.stderr)
    sys.exit(1)
