data Point(x Int, y Int)

data Point3(x, y, z)  # optional types

data one(x); data two(y);

enum op { Plus, Minus }

enum comma1 {  # no trailing comma
  Times,
  Divide 
}

enum trailing_comma {  
  Times,
  Divide,
}

enum no_comma {  
  Times
  Divide
}

enum cflow {  

  Break, Continue, Return(status Int)
}

data Token(id Id, span_id Int, val Str)

enum suffix_op {
  Nullary %Token,  # note this is lexer as an Expr_Symbol
  Unary(op_id Id, arg_word Str)
}

data word(parts Array[WordPart])

# TODO: omit trailing comma
# Need to change dict syntax to @{ }
enum value {
  Str(s Str),

  AssocArray(d Map[Str, Str])
}

#
# Classes
#

class Lexer {
  func Run() {
    echo
    # TODO: Fix separators
    #echo
  };

  virtual Foo() {
    echo
  }
}

echo $'hi\n'

class FileReader : Reader {

  var x Int
  var y

  var a Float; var b;

  # TODO: should this be super() ?
  func init(super, x, y) {
    echo
  }

  override Run() {
    echo

    # Another statement
    echo
  }

}

class OneVar { var a }

# should we allow this?  C++ allows it.
#class OneVar { }

class OneLine { var a; var b }

# wtf why can I use these terminators, but not Op_Newline?
# oh maybe the word parser does something with it?

use 'frontend/syntax'
use 'core/util' log, p_die, foo as bar

use 'one'; use 'two'

use 'bar' as foo


#echo hi
