OPy Compiler and Byterun
========================

The OPy compiler is a Python bytecode compiler written in Python.  See
[Building Oil with the OPy Bytecode Compiler][oil-with-opy].  It's currently
used to translate Python source code in Oil to `.pyc` files.

The `byterun/` directory is a fork of [byterun][].  It's an experiment for
learning what it will take to write a minimal interpreter for Oil.  It can
currently run all Oil unit tests, but isn't otherwise used.

[oil-with-opy]: http://www.oilshell.org/blog/2018/03/04.html

[byterun]: http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html

Very Rough Outline of Future Plans
----------------------------------

- Use `opy/callgraph.py` to find the minimum amount of code we need to compile.
  (Tree shaking).
- Produce a statically typed AST.
  - Add type annotations for functions/constructors, possibly with `.pyi` files
    generated by tests.
  - Add type annotations for class members.  Possibly with something like
    [attrs](http://www.attrs.org/en/stable/)?
  - Add type inference for local variables.
- Use the statically typed AST to generate type-specialized bytecodes.  For
  example, we could have variants of `BINARY_ADD` that know the types of their
  arguments.
- Implement these bytecodes in byterun as a prototype.  Do the spec tests still
  pass?
- Rewrite specialized bytecodes in our own interpeter loop in C.
  - It will not use `import.c`.  Imports are resolved at compile time.
  - This means we also get rid of the app bundle `.zip` format, which is
    causing problems.

Also:

- Strip Oil of runtime dependencies like the Python `re` module.  Rewrite with
  `re2c`.
- Copy the stuff we use out of `posixmodule.c`, `pwdmodule.c`, etc.

Getting started
---------------

Start with https://github.com/oilshell/oil/wiki/Contributing .  This is
necessary to build the `py27.grammar` file and so forth.

Then:

    $ ./smoke.sh opy-hello2  # basic test of compiler and runtime

Compile Oil with the OPy compiler:

    $ ./build.sh oil-repo  # makes _tmp/osh-opy and _tmp/osh-ccompile

Run Oil unit tests, compiled with OPy, under CPython:

    $ ./test.sh oil-unit

Run Oil unit tests, compiled with OPy, under byterun (OPyPy):

    $ ./test.sh oil-unit-byterun   # Run Oil unit tests, compiled with OPy, under CPython


Another way I test it like this:

    $ testdata/regex_compile.py  # run with CPython
    $ ../bin/opyc run testdata/regex_compile.py

(TODO: these should be gold tests)


Demo: speed difference between OSH under CPython and OSH under byterun:

    ./demo.sh osh-byterun-speed

TODO:

- Spec tests
  - ./test.sh spec all  # Some failures due to $0

OPy Compiler Regtest
--------------------

This uses golden data in `_regtest/`.

    ./regtest.sh compile  # note: different files than 'build.sh oil-repo'
    ./regtest.sh verify-golden

OPy Compiler Divergences from CPython
----------------------------

### Lexer

- I don't remember where exactly, but I ran into a bug lexing the CPython test
  suite.  IIRC, CPython's lexer was more lenient about adjacent tokens without
  spaces than `tokenize.py`.
- `heapq.py` had `-*- coding: latin-1 -*-`, which causes problems.  OPy
  should require `utf-8` source anyway.

### Parser

- I ran into a bug where a file like `d = {}`, without a trailing newline,
  gives a parse error.  Adding the newline fixes it.
- print statements aren't allowed; we force Python 3-style `print(x, y,
  file=sys.stderr)`.  I think this is because the parser doesn't know about
  `__future__` statements, so it can't change the parsing mode on the fly.

### Bytecode Compiler

- I think there are no `LOAD_FAST` bytecodes generated?  TODO: Make a bytecode
  histogram using `opy/misc/inspect_pyc`.
- The OPy bytecode is bigger than the CPython bytecode!  Why is that?

