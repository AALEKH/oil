from __future__ import print_function
import cStringIO
"""Python abstract syntax node definitions

This file is automatically generated by Tools/compiler/astgen.py
"""
from .consts import CO_VARARGS, CO_VARKEYWORDS

# NOTE: Similar to pyassem.flatten().
def flatten(seq):
    l = []
    for elt in seq:
        if isinstance(elt, (tuple, list)):
            l.extend(flatten(elt))
        else:
            l.append(elt)
    return l

def flatten_nodes(seq):
    return [n for n in flatten(seq) if isinstance(n, Node)]

nodes = {}


# NOTE: after_equals is a hack to make the output prettier.  You could copy
# _TrySingleLine in asdl/format.py.  That took a long time to get right!
def _PrettyPrint(val, f, indent=0, after_equals=False): 
  indent_str = ' ' * indent

  if isinstance(val, Node):
    val.PrettyPrint(f, indent=indent, after_equals=after_equals)

  elif isinstance(val, list):
    if not after_equals:
      print('%s' % indent_str, end='', file=f)
    print('[', file=f)   # No indent here
    for item in val:
      _PrettyPrint(item, f, indent=indent+2)
    # Not indented as much
    print('%s]' % indent_str, file=f)

  elif isinstance(val, tuple):
    if not after_equals:
      print('%s' % indent_str, end='', file=f)
    print('(', file=f)
    for item in val:
      _PrettyPrint(item, f, indent=indent+2)
    print('%s)' % indent_str, file=f)

  else:
    if not after_equals:
      print('%s' % indent_str, end='', file=f)
    # String or int?
    print('%r' % val, file=f)


class Node(object):
    """Abstract base class for ast nodes."""

    ARGNAMES = []

    def getChildren(self):
        pass # implemented by subclasses

    def __iter__(self):
        for n in self.getChildren():
            yield n

    def asList(self): # for backwards compatibility
        return self.getChildren()

    def getChildNodes(self):
        pass # implemented by subclasses

    def __repr__(self):
        f = cStringIO.StringIO()
        self.PrettyPrint(f)
        return f.getvalue()

    def PrettyPrint(self, f, indent=0, after_equals=False):
        indent_str = ' ' * indent

        if not after_equals:
          print('%s' % indent_str, end='', file=f)
        print('%s(' % self.__class__.__name__, file=f)
        for name in self.ARGNAMES:
          # Print the field name
          print('%s  %s = ' % (indent_str, name), end='', file=f)

          # Print the value
          val = getattr(self, name)

          _PrettyPrint(val, f, indent=indent+2, after_equals=True)

        print('%s)  # %s' % (indent_str, self.__class__.__name__), file=f)


class EmptyNode(Node):
    pass

class Expression(Node):
    # Expression is an artificial node class to support "eval"
    nodes["expression"] = "Expression"
    def __init__(self, node):
        self.node = node

    def getChildren(self):
        return self.node,

    def getChildNodes(self):
        return self.node,

    def __repr__(self):
        return "Expression(%s)" % (repr(self.node))

class Add(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class And(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class AssAttr(Node):
    ARGNAMES = ['expr', 'attrname', 'flags']
    def __init__(self, expr, attrname, flags, lineno=None):
        self.expr = expr
        self.attrname = attrname
        self.flags = flags
        self.lineno = lineno

    def getChildren(self):
        return self.expr, self.attrname, self.flags

    def getChildNodes(self):
        return self.expr,

class AssList(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class AssName(Node):
    ARGNAMES = ['name', 'flags']
    def __init__(self, name, flags, lineno=None):
        self.name = name
        self.flags = flags
        self.lineno = lineno

    def getChildren(self):
        return self.name, self.flags

    def getChildNodes(self):
        return ()

class AssTuple(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Assert(Node):
    ARGNAMES = ['test', 'fail']
    def __init__(self, test, fail, lineno=None):
        self.test = test
        self.fail = fail
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.test)
        children.append(self.fail)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        if self.fail is not None:
            nodelist.append(self.fail)
        return tuple(nodelist)

class Assign(Node):
    ARGNAMES = ['nodes', 'expr']
    def __init__(self, nodes, expr, lineno=None):
        self.nodes = nodes
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.expr)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        nodelist.append(self.expr)
        return tuple(nodelist)

class AugAssign(Node):
    ARGNAMES = ['node', 'op', 'expr']
    def __init__(self, node, op, expr, lineno=None):
        self.node = node
        self.op = op
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.node, self.op, self.expr

    def getChildNodes(self):
        return self.node, self.expr

class Backquote(Node):
    ARGNAMES = ['expr']
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

class Bitand(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Bitor(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Bitxor(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Break(Node):
    ARGNAMES = []
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

class CallFunc(Node):
    ARGNAMES = ['node', 'args', 'star_args', 'dstar_args']
    def __init__(self, node, args, star_args = None, dstar_args = None, lineno=None):
        self.node = node
        self.args = args
        self.star_args = star_args
        self.dstar_args = dstar_args
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.node)
        children.extend(flatten(self.args))
        children.append(self.star_args)
        children.append(self.dstar_args)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.node)
        nodelist.extend(flatten_nodes(self.args))
        if self.star_args is not None:
            nodelist.append(self.star_args)
        if self.dstar_args is not None:
            nodelist.append(self.dstar_args)
        return tuple(nodelist)

class Class(Node):
    ARGNAMES = ['name', 'bases', 'doc', 'code', 'decorators']
    def __init__(self, name, bases, doc, code, decorators = None, lineno=None):
        self.name = name
        self.bases = bases
        self.doc = doc
        self.code = code
        self.decorators = decorators
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.name)
        children.extend(flatten(self.bases))
        children.append(self.doc)
        children.append(self.code)
        children.append(self.decorators)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.bases))
        nodelist.append(self.code)
        if self.decorators is not None:
            nodelist.append(self.decorators)
        return tuple(nodelist)

class Compare(Node):
    ARGNAMES = ['expr', 'ops']
    def __init__(self, expr, ops, lineno=None):
        self.expr = expr
        self.ops = ops
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.ops))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.ops))
        return tuple(nodelist)

class Const(Node):
    ARGNAMES = ['value']
    def __init__(self, value, lineno=None):
        self.value = value
        self.lineno = lineno

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return ()

class Continue(Node):
    ARGNAMES = []
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

class Decorators(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Dict(Node):
    ARGNAMES = ['items']
    def __init__(self, items, lineno=None):
        self.items = items
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.items))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.items))
        return tuple(nodelist)

class DictComp(Node):
    ARGNAMES = ['key', 'value', 'quals']
    def __init__(self, key, value, quals, lineno=None):
        self.key = key
        self.value = value
        self.quals = quals
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.key)
        children.append(self.value)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.key)
        nodelist.append(self.value)
        nodelist.extend(flatten_nodes(self.quals))
        return tuple(nodelist)

class Discard(Node):
    ARGNAMES = ['expr']
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

class Div(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class Ellipsis(Node):
    ARGNAMES = []
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

class Exec(Node):
    ARGNAMES = ['expr', 'locals', 'globals']
    def __init__(self, expr, locals, globals, lineno=None):
        self.expr = expr
        self.locals = locals
        self.globals = globals
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.locals)
        children.append(self.globals)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.locals is not None:
            nodelist.append(self.locals)
        if self.globals is not None:
            nodelist.append(self.globals)
        return tuple(nodelist)

class FloorDiv(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class For(Node):
    ARGNAMES = ['assign', 'list', 'body', 'else_']
    def __init__(self, assign, list, body, else_, lineno=None):
        self.assign = assign
        self.list = list
        self.body = body
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

class From(Node):
    ARGNAMES = ['modname', 'names', 'level']
    def __init__(self, modname, names, level, lineno=None):
        self.modname = modname
        self.names = names
        self.level = level
        self.lineno = lineno

    def getChildren(self):
        return self.modname, self.names, self.level

    def getChildNodes(self):
        return ()

class Function(Node):
    ARGNAMES = ['decorators', 'name', 'argnames', 'defaults', 'flags', 'doc', 'code']
    def __init__(self, decorators, name, argnames, defaults, flags, doc, code, lineno=None):
        self.decorators = decorators
        self.name = name
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.doc = doc
        self.code = code
        self.lineno = lineno
        self.varargs = self.kwargs = None
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1


    def getChildren(self):
        children = []
        children.append(self.decorators)
        children.append(self.name)
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.decorators is not None:
            nodelist.append(self.decorators)
        nodelist.extend(flatten_nodes(self.defaults))
        nodelist.append(self.code)
        return tuple(nodelist)

class GenExpr(Node):
    ARGNAMES = ['code']
    def __init__(self, code, lineno=None):
        self.code = code
        self.lineno = lineno
        self.argnames = ['.0']
        self.varargs = self.kwargs = None


    def getChildren(self):
        return self.code,

    def getChildNodes(self):
        return self.code,

class GenExprFor(Node):
    ARGNAMES = ['assign', 'iter', 'ifs']
    def __init__(self, assign, iter, ifs, lineno=None):
        self.assign = assign
        self.iter = iter
        self.ifs = ifs
        self.lineno = lineno
        self.is_outmost = False

    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.iter)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.iter)
        nodelist.extend(flatten_nodes(self.ifs))
        return tuple(nodelist)

class GenExprIf(Node):
    ARGNAMES = ['test']
    def __init__(self, test, lineno=None):
        self.test = test
        self.lineno = lineno

    def getChildren(self):
        return self.test,

    def getChildNodes(self):
        return self.test,

class GenExprInner(Node):
    ARGNAMES = ['expr', 'quals']
    def __init__(self, expr, quals, lineno=None):
        self.expr = expr
        self.quals = quals
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.quals))
        return tuple(nodelist)

class Getattr(Node):
    ARGNAMES = ['expr', 'attrname']
    def __init__(self, expr, attrname, lineno=None):
        self.expr = expr
        self.attrname = attrname
        self.lineno = lineno

    def getChildren(self):
        return self.expr, self.attrname

    def getChildNodes(self):
        return self.expr,

class Global(Node):
    ARGNAMES = ['names']
    def __init__(self, names, lineno=None):
        self.names = names
        self.lineno = lineno

    def getChildren(self):
        return self.names,

    def getChildNodes(self):
        return ()

class If(Node):
    ARGNAMES = ['tests', 'else_']
    def __init__(self, tests, else_, lineno=None):
        self.tests = tests
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.tests))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.tests))
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

class IfExp(Node):
    ARGNAMES = ['test', 'then', 'else_']
    def __init__(self, test, then, else_, lineno=None):
        self.test = test
        self.then = then
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        return self.test, self.then, self.else_

    def getChildNodes(self):
        return self.test, self.then, self.else_

class Import(Node):
    ARGNAMES = ['names']
    def __init__(self, names, lineno=None):
        self.names = names
        self.lineno = lineno

    def getChildren(self):
        return self.names,

    def getChildNodes(self):
        return ()

class Invert(Node):
    ARGNAMES = ['expr']
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

class Keyword(Node):
    ARGNAMES = ['name', 'expr']
    def __init__(self, name, expr, lineno=None):
        self.name = name
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.name, self.expr

    def getChildNodes(self):
        return self.expr,

class Lambda(Node):
    ARGNAMES = ['argnames', 'defaults', 'flags', 'code']
    def __init__(self, argnames, defaults, flags, code, lineno=None):
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.code = code
        self.lineno = lineno
        self.varargs = self.kwargs = None
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1


    def getChildren(self):
        children = []
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.defaults))
        nodelist.append(self.code)
        return tuple(nodelist)

class LeftShift(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class List(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class ListComp(Node):
    ARGNAMES = ['expr', 'quals']
    def __init__(self, expr, quals, lineno=None):
        self.expr = expr
        self.quals = quals
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.quals))
        return tuple(nodelist)

class ListCompFor(Node):
    ARGNAMES = ['assign', 'list', 'ifs']
    def __init__(self, assign, list, ifs, lineno=None):
        self.assign = assign
        self.list = list
        self.ifs = ifs
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.extend(flatten_nodes(self.ifs))
        return tuple(nodelist)

class ListCompIf(Node):
    ARGNAMES = ['test']
    def __init__(self, test, lineno=None):
        self.test = test
        self.lineno = lineno

    def getChildren(self):
        return self.test,

    def getChildNodes(self):
        return self.test,

class Mod(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class Module(Node):
    ARGNAMES = ['doc', 'node']
    def __init__(self, doc, node, lineno=None):
        self.doc = doc
        self.node = node
        self.lineno = lineno

    def getChildren(self):
        return self.doc, self.node

    def getChildNodes(self):
        return self.node,

class Mul(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class Name(Node):
    ARGNAMES = ['name']
    def __init__(self, name, lineno=None):
        self.name = name
        self.lineno = lineno

    def getChildren(self):
        return self.name,

    def getChildNodes(self):
        return ()

class Not(Node):
    ARGNAMES = ['expr']
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

class Or(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Pass(Node):
    ARGNAMES = []
    def __init__(self, lineno=None):
        self.lineno = lineno

    def getChildren(self):
        return ()

    def getChildNodes(self):
        return ()

class Power(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class Print(Node):
    ARGNAMES = ['nodes', 'dest']
    def __init__(self, nodes, dest, lineno=None):
        self.nodes = nodes
        self.dest = dest
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        if self.dest is not None:
            nodelist.append(self.dest)
        return tuple(nodelist)

class Printnl(Node):
    ARGNAMES = ['nodes', 'dest']
    def __init__(self, nodes, dest, lineno=None):
        self.nodes = nodes
        self.dest = dest
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        if self.dest is not None:
            nodelist.append(self.dest)
        return tuple(nodelist)

class Raise(Node):
    ARGNAMES = ['expr1', 'expr2', 'expr3']
    def __init__(self, expr1, expr2, expr3, lineno=None):
        self.expr1 = expr1
        self.expr2 = expr2
        self.expr3 = expr3
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr1)
        children.append(self.expr2)
        children.append(self.expr3)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.expr1 is not None:
            nodelist.append(self.expr1)
        if self.expr2 is not None:
            nodelist.append(self.expr2)
        if self.expr3 is not None:
            nodelist.append(self.expr3)
        return tuple(nodelist)

class Return(Node):
    ARGNAMES = ['value']
    def __init__(self, value, lineno=None):
        self.value = value
        self.lineno = lineno

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return self.value,

class RightShift(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class Set(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class SetComp(Node):
    ARGNAMES = ['expr', 'quals']
    def __init__(self, expr, quals, lineno=None):
        self.expr = expr
        self.quals = quals
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.quals))
        return tuple(nodelist)

class Slice(Node):
    ARGNAMES = ['expr', 'flags', 'lower', 'upper']
    def __init__(self, expr, flags, lower, upper, lineno=None):
        self.expr = expr
        self.flags = flags
        self.lower = lower
        self.upper = upper
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.append(self.lower)
        children.append(self.upper)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.lower is not None:
            nodelist.append(self.lower)
        if self.upper is not None:
            nodelist.append(self.upper)
        return tuple(nodelist)

class Sliceobj(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Stmt(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class Sub(Node):
    ARGNAMES = ['left', 'right']
    def __init__(self, leftright, lineno=None):
        self.left = leftright[0]
        self.right = leftright[1]
        self.lineno = lineno

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return self.left, self.right

class Subscript(Node):
    ARGNAMES = ['expr', 'flags', 'subs']
    def __init__(self, expr, flags, subs, lineno=None):
        self.expr = expr
        self.flags = flags
        self.subs = subs
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.extend(flatten(self.subs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.subs))
        return tuple(nodelist)

class TryExcept(Node):
    ARGNAMES = ['body', 'handlers', 'else_']
    def __init__(self, body, handlers, else_, lineno=None):
        self.body = body
        self.handlers = handlers
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.body)
        children.extend(flatten(self.handlers))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.body)
        nodelist.extend(flatten_nodes(self.handlers))
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

class TryFinally(Node):
    ARGNAMES = ['body', 'final']
    def __init__(self, body, final, lineno=None):
        self.body = body
        self.final = final
        self.lineno = lineno

    def getChildren(self):
        return self.body, self.final

    def getChildNodes(self):
        return self.body, self.final

class Tuple(Node):
    ARGNAMES = ['nodes']
    def __init__(self, nodes, lineno=None):
        self.nodes = nodes
        self.lineno = lineno

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return tuple(nodelist)

class UnaryAdd(Node):
    ARGNAMES = ['expr']
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

class UnarySub(Node):
    ARGNAMES = ['expr']
    def __init__(self, expr, lineno=None):
        self.expr = expr
        self.lineno = lineno

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return self.expr,

class While(Node):
    ARGNAMES = ['test', 'body', 'else_']
    def __init__(self, test, body, else_, lineno=None):
        self.test = test
        self.body = body
        self.else_ = else_
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.test)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return tuple(nodelist)

class With(Node):
    ARGNAMES = ['expr', 'vars', 'body']
    def __init__(self, expr, vars, body, lineno=None):
        self.expr = expr
        self.vars = vars
        self.body = body
        self.lineno = lineno

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.vars)
        children.append(self.body)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.vars is not None:
            nodelist.append(self.vars)
        nodelist.append(self.body)
        return tuple(nodelist)

class Yield(Node):
    ARGNAMES = ['value']
    def __init__(self, value, lineno=None):
        self.value = value
        self.lineno = lineno

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return self.value,

for name, obj in globals().items():
    if isinstance(obj, type) and issubclass(obj, Node):
        nodes[name.lower()] = obj
