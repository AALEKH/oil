# tea/testdata/data-enum.tea

data Point(x Int, y Int)

data Point3(x, y, z)  # optional types

data one(x); data two(y);

enum empty { }

enum op { Plus, Minus }  # one line

enum comma1 {  # no trailing comma
  Times,
  Divide 
}

enum trailing_comma {  
  Times,
  Divide,
}

enum no_comma {  # newlines are commas
  Times
  Divide
}

enum cflow {  
  Break, Continue, Return(status Int)
}

data Token(id Id, span_id Int, val Str)

enum suffix_op {
  Nullary %Token,  # note this is lexer as an Expr_Symbol
  Unary(op_id Id, arg_word Str)
}

data word(parts Array[WordPart])

enum value {
  Str(s Str),
  AssocArray(d Map[Str, Str])
}

